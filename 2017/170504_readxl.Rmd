---
title: "readxlパッケージの1.0.0での主要な変更点" 
author: "Shinya Uryu"
date: "2017年5月4日"
output: 
  md_document:
    variant: markdown_github
---

```{r [SETTING], include = FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, 
                      message = FALSE, error = FALSE, warning = FALSE,
                      fig.align = "center",
                      tidy = TRUE,
                      tidy.opts = list(blank = FALSE, width.cutoff = 40))
```

```{r, eval = TRUE, include = FALSE}
library(magrittr)
library(remoji)
library(pumpkin.seeds)
```

先日、エクセルファイルのデータをRに読み込ませるパッケージの[**readxl**パッケージ](http://readxl.tidyverse.org/)の1.0がCRANに登録されました。

実はしばらく更新を追えていなくて、更新してみたら、色々な新機能があったのでメモしておきます。まとめると以下の通りです。気になった点を挙げていますので、詳細は[NEWS](http://readxl.tidyverse.org/news/index.html)をご覧ください。

- エクセルファイル読み込み関数に2つの引数の追加
     - 範囲を指定した読み込みのための*range*引数
     - 読み込み時の行制限として*n_max*の適用
- 列指定の際の挙動に大きな変更
     - *col_types*引数にlist, logical, guessが指定することが可能に
     - blankの廃止。代わりにskipの指定
     - guess_max
     - trim_ws
     - 欠損値に複数の値を指定可能に
     - ...
- その他
     - 変数名の初期値が*X__1*から*X__0*に変更

特に気になるのが読み込み時の範囲指定と*col_types*引数のlist対応です。それぞれ詳しく見ていきましょう。

## 読み込み時の範囲指定

エクセルファイルだと、目的のデータ以外の備考や合計値を算出している行などが含まれていることがよくありますね。これまでの
readxlパッケージでは、対象のシートに含まれるセルをよしなにデータフレームに変換して読み込み、そこから利用者が必要なデータを選択するという手間がありました。今回のバージョンで追加された*range*引数は、その手間を省略するのに大変役立ちます。

エクセルファイルを印刷する際、「範囲指定した部分のみを印刷」という処理をしたことがある人が多いと思います。*range*引数はそれと同じく、`read_excel()`の実行時に範囲を指定できるようになりました。これにより直接必要な箇所だけを読み込ませることができます。

*range*引数の指定方法は、エクセルで使われる`A1:B2` (A1セルからB2セルまで)のような記述が可能です。また範囲指定の専用の関数として`cell_rows()`、`anchored()`なども実装されています。

## col_types引数のlist対応

Rのデータフレームの性質として、変数内の値はベクトルとして扱われ、そのデータ型は統一される、というものがあります。
そのため、文字列と日付が含まれる列を読み込む場合、日付は文字列に変換されてしまいます。一方でリストは異なるデータ型の値を保持するのに適しています。

今回、引数*col_types*がlistに対応したことで、複数のデータ型が含まれる列であっても元の値を保持しておくことが可能になっています。少しわかりにくいのでヘルプに掲載されているコードを実行してみましょう。

```{r}
library(readxl)

(df <- read_excel(
  readxl_example("clippy.xlsx"),
  col_types = c("text", "list")
))
```

2列目、value列はlistとして格納されているのがわかります。各行は、実際の値でなく、データ型を示しています。リストとして保存することで、文字列、日付・時間、数値という異なるデータ型が共存しています。比較のため、通常の方法で読み込む例も示します。

```{r}
read_excel(readxl_example("clippy.xlsx"))
```

今度は直接、値が出力されました。しかし3行目の値が`39083`となっている点に注意です。これは元のエクセルファイルでは日付となっていたものでした。value列(ベクトル)が文字列として処理された結果、値が変化してしまいました。今回のアップデートでは、list列として処理することで、この問題を改善しています。

**readxl**のメジャーリリースとなる1.0.0が出たことで、Clippy君は悲しんでいるようですが、アップデートが済んでいない方は、ぜひ新しい**readxl**をお試しください。

Enjoy!
